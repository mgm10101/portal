// src/services/financialService.ts

import { supabase } from '../supabaseClient'; 
import { 
    ItemMaster, 
    InvoiceHeader, 
    FullInvoice, 
    StudentInfo, 
    InvoiceSubmissionData,
    InvoiceLineItem,
    // Import the new type we will define in database.ts
    OutstandingBalanceReview 
} from '../types/database'; 

// Helper types to represent the raw data returned by Supabase 
// (where all 'numeric' database fields are returned as 'string' before coercion)
// --- FIX 1: Revert numeric fields to SNAKE_CASE, as returned by the database/PostgREST
type RawInvoiceData = Omit<InvoiceHeader, 'subtotal' | 'totalAmount' | 'paymentMade' | 'balanceDue' | 'broughtforward_amount' | 'class_name'> & {
    subtotal: string;
    total_amount: string; // ‚úÖ FIX: Changed to use snake_case for raw DB response
    payment_made: string; // ‚úÖ FIX: Changed to use snake_case for raw DB response
    balance_due: string; // ‚úÖ FIX: Changed to use snake_case for raw DB response
    broughtforward_amount: string | null; // Adjusted for nullable numeric
    // --- ADDED: Structure for the joined 'students' table to retrieve class_name ---
    students: { class_name: string | null } | null;
    // -----------------------------------------------------------------------------
};

// --- BATCH CREATION TYPES ---

// Define the required fields for a line item in the context of the Batch Form
interface BatchLineItem {
    item_master_id: string;
    unitPrice: number;
    quantity: number;
    discount: number;
    // NOTE: Adding itemName and lineTotal is crucial for reusability with createInvoice
    itemName: string; 
    lineTotal: number;
    description: string | null;
}

export interface BatchCreationData {
    selectedStudentIds: string[]; // List of admission numbers
    lineItems: BatchLineItem[];
    invoiceDate: string;
    dueDate: string;
    description: string;
}
// --- END BATCH CREATION TYPES ---


// --- NEW: BALANCE BROUGHT FORWARD TYPES (Internal Service Use) ---

// Type for the data to be written to the balance_brought_forward table
interface BalanceBroughtForwardPayload {
    student_name: string;
    admission_number: string;
    invoice_number: string;
    invoice_description: string | null;
    balance_due: number;
}
// --- END BALANCE BROUGHT FORWARD TYPES ---


// --- A. Student & Master Item Fetching (UPDATED) ---

export async function fetchStudents(): Promise<StudentInfo[]> {
    console.log("üêõ [DEBUG] Fetching student data for invoice form...");
    const { data, error } = await supabase
        .from('students')
        // üí° FIX: Include 'class_name' in the select statement
        .select('admission_number, name, class_name'); 
    if (error) {
        console.error("‚ùå [ERROR] Error fetching students:", error);
        throw new Error('Failed to fetch students data from the database.');
    }
    console.log(`‚úÖ [DEBUG] Successfully fetched ${data.length} students.`);
    // The data returned now matches the updated StudentInfo[] type
    return data as StudentInfo[]; 
}

export async function fetchMasterItems(): Promise<ItemMaster[]> {
    console.log("üêõ [DEBUG] Fetching master items...");
    const { data, error } = await supabase
        .from('item_master')
        .select('*');
    if (error) {
        console.error("‚ùå [ERROR] Error fetching master items:", error);
        throw new Error('Could not fetch available fees/items.');
    }
    // No change here, current_unit_price is snake_case in ItemMaster which is fine
    const typedData: ItemMaster[] = data.map((item: any) => ({
        ...item,
        current_unit_price: parseFloat(item.current_unit_price),
    }));
    console.log(`‚úÖ [DEBUG] Successfully fetched ${typedData.length} master items.`);
    return typedData;
}

// --- A. Item Master CRUD Functions (NEW) ---

// New type for creating a master item (since ID and created_at are generated by DB)
type NewItemMaster = Omit<ItemMaster, 'id' | 'created_at'>;

/**
 * Creates a new master item.
 * @param data The item details (name, price, description, status).
 * @returns The newly created ItemMaster object.
 */
export async function createMasterItem(data: NewItemMaster): Promise<ItemMaster> {
    console.log("üêõ [DEBUG] Creating new master item:", data.item_name);
    const payload = {
        item_name: data.item_name,
        // Convert number to precise string for DB insertion
        current_unit_price: data.current_unit_price.toFixed(2), 
        description: data.description,
        status: data.status,
    };

    const { data: itemData, error } = await supabase
        .from('item_master')
        .insert(payload)
        .select()
        .single();

    if (error || !itemData) {
        console.error("‚ùå [ERROR] Error creating master item:", error);
        throw new Error(`Failed to create item: ${error?.message}`);
    }

    // Coerce the numeric string back into a number for the client
    const createdItem: ItemMaster = {
        ...itemData,
        current_unit_price: parseFloat(itemData.current_unit_price),
    };
    console.log(`‚úÖ [DEBUG] Master item created with ID: ${createdItem.id}`);
    return createdItem;
}

/**
 * Updates an existing master item (e.g., status or price).
 * @param id The ID of the item to update.
 * @param updates The fields to update.
 * @returns The updated ItemMaster object.
 */
export async function updateMasterItem(id: string, updates: Partial<ItemMaster>): Promise<ItemMaster> {
    console.log(`üêõ [DEBUG] Updating master item ID: ${id}`);
    const payload: { [key: string]: any } = {};

    // Map camelCase to snake_case and handle numeric coercion
    if (updates.item_name !== undefined) payload.item_name = updates.item_name;
    if (updates.description !== undefined) payload.description = updates.description;
    if (updates.status !== undefined) payload.status = updates.status;

    // Convert number to precise string for DB if price is being updated
    if (updates.current_unit_price !== undefined) {
        payload.current_unit_price = updates.current_unit_price.toFixed(2); 
    }

    const { data: itemData, error } = await supabase
        .from('item_master')
        .update(payload)
        .eq('id', id)
        .select()
        .single();

    if (error || !itemData) {
        console.error(`‚ùå [ERROR] Error updating master item ${id}:`, error);
        throw new Error(`Failed to update item: ${error?.message}`);
    }

    // Coerce the numeric string back into a number for the client
    const updatedItem: ItemMaster = {
        ...itemData,
        current_unit_price: parseFloat(itemData.current_unit_price),
    };
    console.log(`‚úÖ [DEBUG] Master item ID ${id} updated.`);
    return updatedItem;
}

/**
 * Deletes a master item.
 * @param id The ID of the item to delete.
 */
export async function deleteMasterItem(id: string): Promise<void> {
    console.log(`üêõ [DEBUG] Deleting master item ID: ${id}`);
    const { error } = await supabase
        .from('item_master')
        .delete()
        .eq('id', id);

    if (error) {
        console.error(`‚ùå [ERROR] Error deleting master item ${id}:`, error);
        throw new Error(`Failed to delete item: ${error.message}`);
    }
    console.log(`‚úÖ [DEBUG] Master item ID ${id} deleted.`);
}


// --- B. Single Invoice CREATE Function (NO CHANGES NEEDED) ---

/**
 * Inserts a new Invoice Header and its associated Line Items in two steps.
 * @param data The structured invoice data from the form.
 * @returns The newly created Invoice Header object, including the generated invoice_number.
 */
export async function createInvoice(data: InvoiceSubmissionData): Promise<InvoiceHeader> {
    
    // 1. --- INSERT INVOICE HEADER ---
    console.log("üêõ [DEBUG] Step 1: Inserting Invoice Header for student:", data.header.admission_number);

    // Prepare the header object for insertion 
    // NOTE: We MUST explicitly map all camelCase fields to snake_case for the database.
    const headerToInsert = {
        // Explicitly map all fields from camelCase (submission type) to snake_case (database)

        // Basic Header Fields (These are usually snake_case in DB but mapped to client-friendly names in TS)
        admission_number: data.header.admission_number,
        name: data.header.name,
        invoice_date: data.header.invoice_date,
        due_date: data.header.due_date,
        
        // Status and Descriptions
        status: data.header.status || 'Pending',
        description: data.header.description || null,
        
        // Brought Forward Fields
        broughtforward_description: data.header.broughtforward_description || null,
        broughtforward_amount: data.header.broughtforward_amount || 0.00,
        
        // Calculated/Required Fields (Must use snake_case for DB)
        subtotal: data.header.subtotal,
        total_amount: data.header.totalAmount, 
        
        // *** FIX: payment_made and balance_due are mapped explicitly ***
        payment_made: data.header.paymentMade, 
        // Calculate initial balance due for insertion payload
        balance_due: data.header.totalAmount - data.header.paymentMade,
    };

    const { data: headerData, error: headerError } = await supabase
        .from('invoices')
        .insert(headerToInsert)
        .select() // Request the newly inserted record
        .single();
    
    if (headerError || !headerData) {
        console.error("‚ùå [ERROR] Error inserting Invoice Header:", headerError);
        throw new Error(`Failed to create invoice header: ${headerError?.message}`);
    }
    
    const newInvoiceNumber = headerData.invoice_number;
    console.log(`‚úÖ [DEBUG] Invoice Header inserted. New Invoice Number: ${newInvoiceNumber}`);
    
    
    // 2. --- INSERT INVOICE LINE ITEMS ---
    if (data.line_items.length > 0) {
        console.log("üêõ [DEBUG] Step 2: Inserting Line Items...", data.line_items.length);
        
        // Map the line items to include the generated invoice_number
        // NOTE: Mapping camelCase fields back to the expected snake_case for DB insertion.
        const lineItemsToInsert = data.line_items.map(item => ({
            
            // Explicitly map all necessary fields to snake_case for the DB
            invoice_number: newInvoiceNumber,
            item_master_id: item.item_master_id,
            description: item.description || null,
            quantity: item.quantity,
            discount: item.discount, // This field is correctly named in both cases

            // Mapping calculated/renamed camelCase fields back to snake_case for DB insertion
            unit_price: item.unitPrice, 
            line_total: item.lineTotal, 
            item_name: item.itemName, // Mapped itemName to item_name (assuming DB uses item_name)
            
            // NOTE: No spread operator '...item' used here either, as that could cause similar issues
        }));
        
        const { error: lineItemError } = await supabase
            .from('invoice_line_items')
            .insert(lineItemsToInsert);

        if (lineItemError) {
            console.error("‚ùå [ERROR] Error inserting Invoice Line Items:", lineItemError);
            throw new Error(`Failed to insert line items for ${newInvoiceNumber}: ${lineItemError.message}`);
        }

        console.log(`‚úÖ [DEBUG] Successfully inserted ${data.line_items.length} line items for ${newInvoiceNumber}.`);
    }

    // 3. --- RETURN COERCED HEADER DATA ---
    const rawHeader = headerData as RawInvoiceData;

    // Coerce the numeric strings back into numbers using the NEW CAMELCASE fields
    // NOTE: This insert returns only the header, so the joined 'students' field will not exist.
    const createdInvoice: InvoiceHeader = {
        // We use the snake_case keys from the RawInvoiceData type
        ...rawHeader, 
        // We explicitly set class_name to null on creation, as it will be correct on refetch.
        class_name: null, 
        subtotal: parseFloat(rawHeader.subtotal),
        // We must access the snake_case field names from the raw response here
        totalAmount: parseFloat(rawHeader.total_amount), 
        paymentMade: parseFloat(rawHeader.payment_made), 
        balanceDue: parseFloat(rawHeader.balance_due), 
        broughtforward_amount: rawHeader.broughtforward_amount ? parseFloat(rawHeader.broughtforward_amount) : null,
    };
    
    return createdInvoice;
}


// --- C. Invoice Fetching Functions (FIXED FOR JOIN AND COERCION) ---

export async function fetchInvoices(): Promise<InvoiceHeader[]> {
    console.log("üêõ [DEBUG] Starting fetch of all invoices with student join...");
    const { data, error } = await supabase
        .from('invoices')
        // üí° FIX: Including the student join using the `select` syntax
        .select(`*, students(class_name)`) 
        .order('created_at', { ascending: false });
        
    if (error) {
        // Log the actual error properties for better debugging
        console.error("‚ùå [ERROR] Error fetching invoices:", error.message, error.details); 
        throw new Error('Could not fetch the list of invoices.');
    }
    
    // Use RawInvoiceData for the incoming data
    const typedData: InvoiceHeader[] = data.map((item: RawInvoiceData) => ({
        // Spread the original properties (non-numeric, non-joined)
        ...item,
        
        // --- MAP CLASS NAME from the JOINED OBJECT ---
        // Access item.students.class_name from the join. Must check for null.
        class_name: item.students ? item.students.class_name : null,
        // ---------------------------------------------
        
        // Coerce strings to numbers using the **CORRECT SNAKE_CASE FIELDS** from the raw data
        subtotal: parseFloat(item.subtotal),
        totalAmount: parseFloat(item.total_amount), // ‚úÖ FIX: Using item.total_amount
        paymentMade: parseFloat(item.payment_made), // ‚úÖ FIX: Using item.payment_made
        balanceDue: parseFloat(item.balance_due), // ‚úÖ FIX: Using item.balance_due
        broughtforward_amount: item.broughtforward_amount ? parseFloat(item.broughtforward_amount) : null,
    }));
    
    console.log(`‚úÖ [DEBUG] Successfully fetched and coerced ${typedData.length} invoices.`);
    return typedData;
}

export async function fetchFullInvoice(invoiceNumber: string): Promise<FullInvoice | null> {
    console.log(`üêõ [DEBUG] Fetching full invoice details for ${invoiceNumber}...`);
    const { data: invoiceData, error: invoiceError } = await supabase
        .from('invoices')
        .select(`
            *,
            students (class_name),
            line_items:invoice_line_items ( * )
        `)
        .eq('invoice_number', invoiceNumber)
        .single();

    if (invoiceError) {
        console.error(`‚ùå [ERROR] Error fetching invoice ${invoiceNumber}:`, invoiceError);
        return null;
    }

    if (!invoiceData) {
        console.warn(`‚ö†Ô∏è [WARNING] No invoice found for number ${invoiceNumber}.`);
        return null;
    }

    // Type the raw incoming data correctly
    const rawFullInvoice = invoiceData as unknown as RawInvoiceData & { line_items: any[] };

    // Map line items
    const coercedLineItems: FullInvoice['line_items'] = rawFullInvoice.line_items.map((item: any) => ({
        // Map snake_case fields from the DB to camelCase in the final InvoiceLineItem object
        id: item.id,
        invoice_number: item.invoice_number,
        item_master_id: item.item_master_id,
        description: item.description,
        itemName: item.item_name, // Map item_name (DB) to itemName (TS)
        
        // Coercion from snake_case string (DB) to camelCase number (TS)
        unitPrice: parseFloat(item.unit_price), 
        lineTotal: parseFloat(item.line_total), 
        discount: parseFloat(item.discount),
        quantity: parseInt(item.quantity), // Quantities are usually integers
    }));
    
    // Coerce header numerics and map the class name
    // üö® FINAL FIX: Use a structured assignment to pick only the required fields from the RawInvoiceData,
    // avoiding the spread operator which includes the nested 'students' object.
    const { 
        students, // Destructure and omit the nested 'students' object
        total_amount, 
        payment_made, 
        balance_due, 
        broughtforward_amount: raw_bf_amount, // Rename to avoid collision
        subtotal: raw_subtotal,
        // Destructure other simple fields that match the InvoiceHeader definition
        ...restOfHeader // Includes all simple, non-numeric fields
    } = rawFullInvoice;

    const coercedInvoice: FullInvoice = {
        ...restOfHeader, // Spread all the non-numeric fields
        // --- MAP CLASS NAME from the JOINED OBJECT ---
        class_name: students ? students.class_name : null, // ‚úÖ FIX: Map the required string
        // ---------------------------------------------
        subtotal: parseFloat(raw_subtotal),
        totalAmount: parseFloat(total_amount), 
        paymentMade: parseFloat(payment_made), 
        balanceDue: parseFloat(balance_due), 
        broughtforward_amount: raw_bf_amount ? parseFloat(raw_bf_amount) : null,
        line_items: coercedLineItems,
    };
    console.log(`‚úÖ [DEBUG] Full invoice ${invoiceNumber} fetched successfully.`);
    return coercedInvoice;
}


// --- D. Batch Invoice Creation (NEW IMPLEMENTATION) ---

/**
 * Creates multiple invoices for a list of students using the single `createInvoice` function.
 * This is simpler and reuses existing logic, assuming users are okay with the waiting time.
 * @param data The batch creation details.
 * @returns A promise resolving to the number of invoices successfully created.
 */
export async function createBatchInvoices(data: BatchCreationData): Promise<number> {
    console.log(`üêõ [DEBUG] Initiating batch invoice creation for ${data.selectedStudentIds.length} requested students.`);
    
    if (data.selectedStudentIds.length === 0) {
        throw new Error("Cannot create batch with zero selected students.");
    }
    
    // 1. Fetch ALL students to get their full names for the header
    const allStudents = await fetchStudents();
    const studentsToInvoice = allStudents.filter(s => data.selectedStudentIds.includes(s.admission_number));

    if (studentsToInvoice.length === 0) {
        console.warn("‚ö†Ô∏è [WARNING] No valid student records found for the selected admission numbers. Batch cancelled.");
        throw new Error("No valid student records found for the selected admission numbers.");
    }

    console.log(`üêõ [DEBUG] Starting batch invoice creation for ${studentsToInvoice.length} filtered students...`);

    let successfullyCreatedCount = 0;
    const failedStudents: { name: string, error: string }[] = [];

    // The line items provided by the BatchForm are almost InvoiceLineItem, just need a cast/map
    const lineItemsToSubmit: InvoiceLineItem[] = data.lineItems as InvoiceLineItem[];
    
    // Calculate Subtotal/Total once for the common line items
    const lineItemsSubtotal = lineItemsToSubmit.reduce((sum, item) => sum + item.lineTotal, 0);
    const totalAmount = lineItemsSubtotal; // No brought-forward for batch creation

    for (const student of studentsToInvoice) {
        console.log(`üêõ [DEBUG] Attempting to create invoice for ${student.name} (${student.admission_number})...`);
        try {
            const submissionData: InvoiceSubmissionData = {
                header: {
                    admission_number: student.admission_number,
                    name: student.name,
                    invoice_date: data.invoiceDate,
                    due_date: data.dueDate,
                    status: 'Pending', 
                    description: data.description, 
                    
                    // Batch creation doesn't typically include carried forward balances
                    broughtforward_description: null,
                    broughtforward_amount: null,
                    
                    // Totals
                    subtotal: lineItemsSubtotal,
                    totalAmount: totalAmount,
                    paymentMade: 0.00, // Always 0.00 for a new invoice
                },
                line_items: lineItemsToSubmit, 
            };

            // Use the existing single invoice function
            await createInvoice(submissionData);
            
            successfullyCreatedCount++;
            console.log(`‚úÖ [DEBUG] Invoice created for ${student.name} (${student.admission_number}).`);

        } catch (error) {
            console.error(`‚ùå [ERROR] Failed to create invoice for ${student.name} (${student.admission_number}):`, error);
            failedStudents.push({ 
                name: student.name, 
                error: (error as Error).message.substring(0, 50) + '...' 
            });
        }
    }
    
    if (failedStudents.length > 0) {
        console.warn(`‚ö†Ô∏è [WARNING] Batch creation completed with ${successfullyCreatedCount} successes and ${failedStudents.length} failures. Failures:`, failedStudents);
        // Note: For simplicity, we'll return the successful count but log the failures.
        // The UI component will need to check the success message for this.
    } else {
        console.log(`‚úÖ [DEBUG] Batch creation successfully created ${successfullyCreatedCount} invoices.`);
    }
    
    return successfullyCreatedCount;
}


// --- E. Single Invoice UPDATE Function (NEW IMPLEMENTATION) ---

/**
 * Updates an existing Invoice Header and its associated Line Items.
 * * IMPORTANT: This implements a "Separate Insert and Update" strategy for line items.
 * - Items with an existing 'id' are UPDATED.
 * - Items without an 'id' are INSERTED as new.
 * - Deletion is NOT supported by the UI/Service and must be handled manually in the DB if required.
 * * @param invoiceNumber The immutable identifier for the invoice being updated.
 * @param data The structured invoice data from the form, including the calculated totals.
 * @returns The updated Invoice Header object.
 */
export async function updateInvoice(invoiceNumber: string, data: InvoiceSubmissionData): Promise<InvoiceHeader> {
    
    // --- 1. UPDATE INVOICE HEADER ---
    console.log(`üêõ [DEBUG] Step 1: Updating Invoice Header for ${invoiceNumber}...`);

    // Only update the editable fields: dueDate, description, and the calculated totals.
    // NOTE: admission_number, name, and invoice_date are NOT updated as per requirements.
    const headerToUpdate = {
        due_date: data.header.due_date,
        description: data.header.description || null,
        
        // Update calculated fields (must be snake_case)
        subtotal: data.header.subtotal,
        total_amount: data.header.totalAmount, 
        
        // Update payment fields (these are editable if the payment form is available)
        payment_made: data.header.paymentMade, 
        balance_due: data.header.totalAmount - data.header.paymentMade,
    };

    const { data: headerData, error: headerError } = await supabase
        .from('invoices')
        .update(headerToUpdate)
        .eq('invoice_number', invoiceNumber)
        .select() // Request the newly updated record
        .single();
    
    if (headerError || !headerData) {
        console.error("‚ùå [ERROR] Error updating Invoice Header:", headerError);
        throw new Error(`Failed to update invoice header ${invoiceNumber}: ${headerError?.message}`);
    }
    
    console.log(`‚úÖ [DEBUG] Invoice Header ${invoiceNumber} updated.`);
    
    // --- 2. SEPARATE LINE ITEMS INTO UPDATE/INSERT GROUPS ---
    const itemsToUpdate = data.line_items.filter(item => item.id);
    const itemsToInsert = data.line_items.filter(item => !item.id);

    console.log(`üêõ [DEBUG] Line Items: Found ${itemsToUpdate.length} items to update and ${itemsToInsert.length} items to insert.`);

    
    // --- 3. HANDLE UPDATES (if any) ---
    if (itemsToUpdate.length > 0) {
        console.log("üêõ [DEBUG] Step 3a: Updating existing Line Items...");
        
        // Supabase/PostgREST does not support true batch-UPDATE from a list of records easily.
        // The most efficient client-side method is a series of single updates or a self-contained transaction (RPC).
        // For simplicity and resilience, we will use a Promise.all over individual updates.
        
        const updatePromises = itemsToUpdate.map(item => {
            // Map the item's editable fields to snake_case for DB
            const lineItemPayload = {
                item_master_id: item.item_master_id,
                description: item.description || null,
                quantity: item.quantity,
                discount: item.discount, 
                unit_price: item.unitPrice, 
                line_total: item.lineTotal, 
                item_name: item.itemName, 
            };
            
            return supabase
                .from('invoice_line_items')
                .update(lineItemPayload)
                .eq('id', item.id);
        });
        
        const updateResults = await Promise.all(updatePromises);
        const updateError = updateResults.find(r => r.error)?.error;
        
        if (updateError) {
             console.error("‚ùå [ERROR] Error updating one or more Line Items:", updateError);
             // Note: In a real system, you'd roll back the header update here.
             throw new Error(`Failed to update some existing line items: ${updateError.message}`);
        }
        console.log(`‚úÖ [DEBUG] Successfully updated ${itemsToUpdate.length} line items.`);
    }

    
    // --- 4. HANDLE INSERTS (if any) ---
    if (itemsToInsert.length > 0) {
        console.log("üêõ [DEBUG] Step 3b: Inserting new Line Items...");
        
        // Map the new line items to include the existing invoice_number
        const lineItemsToInsert = itemsToInsert.map(item => ({
            
            // Explicitly map all necessary fields to snake_case for the DB
            invoice_number: invoiceNumber, // Crucial: Link to the existing invoice
            item_master_id: item.item_master_id,
            description: item.description || null,
            quantity: item.quantity,
            discount: item.discount, 

            // Mapping calculated/renamed camelCase fields back to snake_case for DB insertion
            unit_price: item.unitPrice, 
            line_total: item.lineTotal, 
            item_name: item.itemName, 
        }));
        
        const { error: insertError } = await supabase
            .from('invoice_line_items')
            .insert(lineItemsToInsert);

        if (insertError) {
            console.error("‚ùå [ERROR] Error inserting new Invoice Line Items:", insertError);
            throw new Error(`Failed to insert new line items for ${invoiceNumber}: ${insertError.message}`);
        }

        console.log(`‚úÖ [DEBUG] Successfully inserted ${itemsToInsert.length} new line items.`);
    }

    // --- 5. RETURN COERCED HEADER DATA ---
    const rawHeader = headerData as RawInvoiceData;

    // Coerce the numeric strings back into numbers using the NEW CAMELCASE fields
    const updatedInvoice: InvoiceHeader = {
        // We use the snake_case keys from the RawInvoiceData type
        ...rawHeader,
        // Safest default for an update payload return
        class_name: null, 
        subtotal: parseFloat(rawHeader.subtotal),
        // We must access the snake_case field names from the raw response here
        totalAmount: parseFloat(rawHeader.total_amount), 
        paymentMade: parseFloat(rawHeader.payment_made), 
        balanceDue: parseFloat(rawHeader.balance_due), 
        broughtforward_amount: rawHeader.broughtforward_amount ? parseFloat(rawHeader.broughtforward_amount) : null,
    };
    console.log(`‚úÖ [DEBUG] Update process complete for invoice ${invoiceNumber}.`);
    return updatedInvoice;
}


// --- F. NEW: Outstanding Balance Functions ---

/**
 * Fetches all 'Overdue' invoices for a list of students.
 * @param admissionNumbers List of admission numbers to check.
 * @returns A list of invoices with their outstanding balance.
 */
export async function fetchOutstandingBalances(admissionNumbers: string[]): Promise<OutstandingBalanceReview[]> {
    if (admissionNumbers.length === 0) {
        return [];
    }

    console.log(`üêõ [DEBUG] Fetching overdue balances for ${admissionNumbers.length} students...`);

    // NOTE: We only need a few fields for the review table
    const { data, error } = await supabase
        .from('invoices')
        .select(`
            admission_number,
            name,
            invoice_number,
            description,
            balance_due
        `)
        .in('admission_number', admissionNumbers)
        .eq('status', 'Overdue') // Only look for overdue invoices
        .gt('balance_due', 0) // Only look for invoices with a balance > 0
        .order('name', { ascending: true });

    if (error) {
        console.error("‚ùå [ERROR] Error fetching outstanding balances:", error);
        throw new Error('Failed to fetch outstanding balances.');
    }

    // Coerce numeric strings (balance_due) to numbers and map fields
    const coercedData: OutstandingBalanceReview[] = data.map((item: any) => ({
        admission_number: item.admission_number,
        name: item.name,
        invoice_number: item.invoice_number,
        invoice_description: item.description, // Map 'description' to 'invoice_description'
        balance_due: parseFloat(item.balance_due),
    }));

    console.log(`‚úÖ [DEBUG] Found ${coercedData.length} outstanding balances.`);
    return coercedData;
}


/**
 * Transfers overdue balances to the balance_brought_forward table and deletes original invoices.
 * IMPORTANT: This is an irreversible, transactional operation.
 * @param balancesToTransfer The list of balances to save/delete.
 * @returns The total number of successful deletions/transfers.
 */
export async function finalizeAndTransferBalances(balancesToTransfer: OutstandingBalanceReview[]): Promise<number> {
    if (balancesToTransfer.length === 0) {
        return 0;
    }

    // 1. Prepare data for INSERT (balance_brought_forward table)
    const bbfPayload: BalanceBroughtForwardPayload[] = balancesToTransfer.map(b => ({
        student_name: b.name,
        admission_number: b.admission_number,
        invoice_number: b.invoice_number,
        invoice_description: b.invoice_description,
        // Convert number to precise string for DB insertion
        balance_due: b.balance_due, 
    }));

    // 2. Prepare list of invoice_numbers for DELETE (invoices table)
    const invoiceNumbersToDelete = balancesToTransfer.map(b => b.invoice_number);

    console.log(`üêõ [DEBUG] Initiating transfer for ${bbfPayload.length} balances and deletion of ${invoiceNumbersToDelete.length} invoices...`);

    // --- EXECUTE TRANSACTION (Simulated by sequential operations + error handling) ---
    
    // A. INSERT INTO balance_brought_forward
    const { error: insertError } = await supabase
        .from('balance_brought_forward')
        .insert(bbfPayload);

    if (insertError) {
        console.error("‚ùå [ERROR] Error inserting into balance_brought_forward:", insertError);
        throw new Error(`Failed to save balances to history table: ${insertError.message}`);
    }
    console.log(`‚úÖ [DEBUG] Successfully saved ${bbfPayload.length} records to balance_brought_forward.`);

    // B. DELETE FROM invoices
    const { error: deleteError, count: deletedCount } = await supabase
        .from('invoices')
        .delete({ count: 'exact' }) // Request exact count
        .in('invoice_number', invoiceNumbersToDelete);

    if (deleteError) {
        console.error("‚ùå [ERROR] Error deleting old invoices:", deleteError);
        // CRITICAL: Throw an error but warn that the data was saved.
        throw new Error(`Failed to delete original invoices. Data was saved to history, but old invoices may still exist: ${deleteError.message}`);
    }

    if (deletedCount !== invoiceNumbersToDelete.length) {
         console.warn(`‚ö†Ô∏è [WARNING] Expected to delete ${invoiceNumbersToDelete.length} invoices, but only ${deletedCount} were deleted.`);
    }

    console.log(`‚úÖ [DEBUG] Successfully deleted ${deletedCount} invoices.`);
    return deletedCount || 0;
}